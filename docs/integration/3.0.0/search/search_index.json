{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mobile paymentSDK Integration Guide for iOS \u00b6 Introduction \u00b6 paymentSDK was created to provide card payments and make PCI SAQ-A compliance easy. It decreases merchant integration effort and offers nice UX. Beside Card payments alternative payment methods were implemented to reduce integration costs on merchant side. Merchants shall use paymentSDK only when it is necessary and useful. It means when you need interaction with consumer because mobile devices are unreliable (battery, network, ...). You can integrate gateway REST API to trigger recurring payments to avoid unreliable mobile devices. Your solutions shall not solely rely on paymentSDK responses. Wirecard Payment Gateway offers more reliable way of payment result delivery. You can set Instant Payment Notifications in your merchant account configuration or you can override IPN account configuration in payment request Mobile paymentSDK is divided into a core framework and optional frameworks, one for each payment method. With this modular approach, you can pick and choose what you need: a few payment methods (or even just one) or the full selection. Below, we will briefly go through the basic requirements/dependencies, but also code examples for client initialization and processing the payment response on your end. System Requirements \u00b6 Operating system \u00b6 iOS versions: 9.x , 10.x , 11.x , 12.x Device Requirements \u00b6 iPhone iPad iPhone 4s (iOS 9.x) iPad 2 iPhone 5 iPad (3\u02b3\u1d48 generation) iPhone 5c iPad (4\u1d57\u02b0 generation) iPhone 5s iPad Air iPhone 6 iPad Air 2 iPhone 6 Plus iPad (5\u1d57\u02b0 generation) iPhone 6S iPad (6\u1d57\u02b0 generation) iPhone 6S Plus iPad mini iPhone SE iPad mini 2 iPhone 7 iPad mini 3 iPhone 7 Plus iPad mini 4 iPhone 8 iPad Pro iPhone 8 Plus iPhone X iPhone X\ud83c\udd42 iPhone X\ud83c\udd42 Max iPhone X\ud83c\udd41 Integration Details \u00b6 Cocoapods \u00b6 CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 50 thousand libraries and is used in over 3 million apps. Wirecard paymentSDK is one of them. Available Cocoapods subspecs: 1 2 3 4 5 6 7 8 9 10 pod 'paymentSDK' , '~> 3.0.0' # or you can use only needed subspecs to decrease your app's size and to avoid granting redundant permissions. pod 'paymentSDK/ApplePay' , '~> 3.0.0' pod 'paymentSDK/Card' , '~> 3.0.0' pod 'paymentSDK/CardScanner' , '~> 3.0.0' pod 'paymentSDK/PayPal' , '~> 3.0.0' pod 'paymentSDK/SEPA' , '~> 3.0.0' pod 'paymentSDK/IBANScanner' , '~> 3.0.0' pod 'paymetnSDK/ZAPP' , '~> 3.0.0' Available gateways \u00b6 Gateway Hostname Germany - production api.wirecard.com Germany - test api-test.wirecard.com Singapore - production api.wirecard.com.sg Singapore - test test.wirecard.com.sg UK & Ireland - production engine.elastic-payments.com UK & Ireland - test sandbox-engine.thesolution.com Code Examples \u00b6 Client initialization \u00b6 When creating a payment object, don't forget to initialize the client first: Swift 1 Objective-C 1 2 3 4 5 6 7 8 9 NSError * error = nil ; WDECClientParameters * parameters = [ WDECClientParameters new ]; parameters . timeoutInterval = 30 ; self . client = [[ WDECClient alloc ] initWithHostname : @\"api.wirecard.com\" parameters : parameters error : & error ]; // or with default network requests timeout 60 seconds self . client = [[ WDECClient alloc ] initWithHostname : @\"api.wirecard.com\" error : & error ]; For a successful initialization, WDECClient requires Wirecard payment gateway hostname and optional parameters . Check payment \u00b6 This is example code for requesting transaction result (as part of recovery scenario), after the payment goes through: Swift 1 Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 WDECPayment * payment = [ WDECPayment new ]; payment . merchantAccountID = @\"example-123\" ; payment . requestID = @\"example-123\" ; payment . signature = @\"server side computed signature signed by secret key\" ; // data can be reused from failed transaction @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); if ( error ) { // in error case - error object is always provided IPLogError ( @\"error: %@\" , error ); } // response object is provided from gateway. // in case of failed transaction error is created as well [ self handleResponse : response error : error ]; }; [ self . client checkPayment : payment withCompletion : completionBlock ]; Override Instant Payment Notification \u00b6 This is example code for overriding Instant Payment Notification URL: Swift 1 Objective-C 1 2 3 4 5 WDECNotification * notification = [ WDECNotification new ]; notification . URL = [ NSURL URLWithString : @\"https://example.com/notification\" ]; WDECPayment * payment = [ WDECCardPayment new ]; payment . notifications = @[ notification ] ; User Interface customization \u00b6 TODO Swift 1 Objective-C 1 User Interface localization \u00b6 TODO Swift 1 Objective-C 1 API Reference \u00b6 WDECClient WDECPayment WDECPaymentResponse WDECErrorCode -s provided in [ NSError code ]","title":"Start Here"},{"location":"#mobile-paymentsdk-integration-guide-for-ios","text":"","title":"Mobile paymentSDK Integration Guide for iOS"},{"location":"#introduction","text":"paymentSDK was created to provide card payments and make PCI SAQ-A compliance easy. It decreases merchant integration effort and offers nice UX. Beside Card payments alternative payment methods were implemented to reduce integration costs on merchant side. Merchants shall use paymentSDK only when it is necessary and useful. It means when you need interaction with consumer because mobile devices are unreliable (battery, network, ...). You can integrate gateway REST API to trigger recurring payments to avoid unreliable mobile devices. Your solutions shall not solely rely on paymentSDK responses. Wirecard Payment Gateway offers more reliable way of payment result delivery. You can set Instant Payment Notifications in your merchant account configuration or you can override IPN account configuration in payment request Mobile paymentSDK is divided into a core framework and optional frameworks, one for each payment method. With this modular approach, you can pick and choose what you need: a few payment methods (or even just one) or the full selection. Below, we will briefly go through the basic requirements/dependencies, but also code examples for client initialization and processing the payment response on your end.","title":"Introduction"},{"location":"#system-requirements","text":"","title":"System Requirements"},{"location":"#operating-system","text":"iOS versions: 9.x , 10.x , 11.x , 12.x","title":"Operating system"},{"location":"#device-requirements","text":"iPhone iPad iPhone 4s (iOS 9.x) iPad 2 iPhone 5 iPad (3\u02b3\u1d48 generation) iPhone 5c iPad (4\u1d57\u02b0 generation) iPhone 5s iPad Air iPhone 6 iPad Air 2 iPhone 6 Plus iPad (5\u1d57\u02b0 generation) iPhone 6S iPad (6\u1d57\u02b0 generation) iPhone 6S Plus iPad mini iPhone SE iPad mini 2 iPhone 7 iPad mini 3 iPhone 7 Plus iPad mini 4 iPhone 8 iPad Pro iPhone 8 Plus iPhone X iPhone X\ud83c\udd42 iPhone X\ud83c\udd42 Max iPhone X\ud83c\udd41","title":"Device Requirements"},{"location":"#integration-details","text":"","title":"Integration Details"},{"location":"#cocoapods","text":"CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 50 thousand libraries and is used in over 3 million apps. Wirecard paymentSDK is one of them. Available Cocoapods subspecs: 1 2 3 4 5 6 7 8 9 10 pod 'paymentSDK' , '~> 3.0.0' # or you can use only needed subspecs to decrease your app's size and to avoid granting redundant permissions. pod 'paymentSDK/ApplePay' , '~> 3.0.0' pod 'paymentSDK/Card' , '~> 3.0.0' pod 'paymentSDK/CardScanner' , '~> 3.0.0' pod 'paymentSDK/PayPal' , '~> 3.0.0' pod 'paymentSDK/SEPA' , '~> 3.0.0' pod 'paymentSDK/IBANScanner' , '~> 3.0.0' pod 'paymetnSDK/ZAPP' , '~> 3.0.0'","title":"Cocoapods"},{"location":"#available-gateways","text":"Gateway Hostname Germany - production api.wirecard.com Germany - test api-test.wirecard.com Singapore - production api.wirecard.com.sg Singapore - test test.wirecard.com.sg UK & Ireland - production engine.elastic-payments.com UK & Ireland - test sandbox-engine.thesolution.com","title":"Available gateways"},{"location":"#code-examples","text":"","title":"Code Examples"},{"location":"#client-initialization","text":"When creating a payment object, don't forget to initialize the client first: Swift 1 Objective-C 1 2 3 4 5 6 7 8 9 NSError * error = nil ; WDECClientParameters * parameters = [ WDECClientParameters new ]; parameters . timeoutInterval = 30 ; self . client = [[ WDECClient alloc ] initWithHostname : @\"api.wirecard.com\" parameters : parameters error : & error ]; // or with default network requests timeout 60 seconds self . client = [[ WDECClient alloc ] initWithHostname : @\"api.wirecard.com\" error : & error ]; For a successful initialization, WDECClient requires Wirecard payment gateway hostname and optional parameters .","title":"Client initialization"},{"location":"#check-payment","text":"This is example code for requesting transaction result (as part of recovery scenario), after the payment goes through: Swift 1 Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 WDECPayment * payment = [ WDECPayment new ]; payment . merchantAccountID = @\"example-123\" ; payment . requestID = @\"example-123\" ; payment . signature = @\"server side computed signature signed by secret key\" ; // data can be reused from failed transaction @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); if ( error ) { // in error case - error object is always provided IPLogError ( @\"error: %@\" , error ); } // response object is provided from gateway. // in case of failed transaction error is created as well [ self handleResponse : response error : error ]; }; [ self . client checkPayment : payment withCompletion : completionBlock ];","title":"Check payment"},{"location":"#override-instant-payment-notification","text":"This is example code for overriding Instant Payment Notification URL: Swift 1 Objective-C 1 2 3 4 5 WDECNotification * notification = [ WDECNotification new ]; notification . URL = [ NSURL URLWithString : @\"https://example.com/notification\" ]; WDECPayment * payment = [ WDECCardPayment new ]; payment . notifications = @[ notification ] ;","title":"Override Instant Payment Notification"},{"location":"#user-interface-customization","text":"TODO Swift 1 Objective-C 1","title":"User Interface customization"},{"location":"#user-interface-localization","text":"TODO Swift 1 Objective-C 1","title":"User Interface localization"},{"location":"#api-reference","text":"WDECClient WDECPayment WDECPaymentResponse WDECErrorCode -s provided in [ NSError code ]","title":"API Reference"},{"location":"card-payments/","text":"Card Payments \u00b6 Supported Transaction Types \u00b6 This payment method supports the following transaction types : WDECTransactionTypeAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. WDECTransactionTypeAuthorizationOnly - verifies the validity of account holder's card, but does not leave an authorized amount. WDECTransactionTypePurchase - charges the account holder's card and immediately transfers the reserved amount. WDECTransactionTypeReferencedAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. References a previous WDECTransactionTypeAuthorization transaction. WDECTransactionTypeReferencedPurchase - charges the account holder's card and immediately transfers the reserved amount. References a previous WDECTransactionTypePurchase transaction. WDECTransactionTypeTokenize - provides a unique token which represents the tokenized card data. This token then can be used in future transactions. Basic Setup \u00b6 Cocoapods \u00b6 Add to your app's Podfile subspecs: 1 2 3 pod 'paymentSDK/Card' , '~> 3.0.0' # just by adding card scanner subspec consumers get option to scan card pod 'paymentSDK/CardScanner' , '~> 3.0.0' Camera Permission \u00b6 To make sure Card Scanner has permission before using camera to scan card, follow the steps in Apple documentation . You need to include NSCameraUsageDescription in your app's Info.plist file. Basic Card Payment \u00b6 This is a code example for a basic card payment: Swift 1 Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; Note: You can set optional parameters after the payment object is created. Check the API documentation: WDECCardPayment and for more details. Token payment \u00b6 This is a code example for a card payment which uses a card token (obtained from a previous transaction): Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val cardPayment = CardPayment ( signature , requestID , merchantID , transactionType , amount , currency ) // for enabling animated card layout cardPayment . animatedCardPayment = true val cardToken = CardToken () cardToken . tokenId = \"12345678901111\" cardPayment . cardToken = cardToken cardToken . tokenUsageIndicator = true cardToken . requireSecurityCode = true Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cardPayment = new CardPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . build (); // for enabling animated card layout cardPayment . setAnimatedCardPayment ( true ); CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"12345678901111\" ); cardPayment . setCardToken ( cardToken ); cardPayment . setRequireSecurityCode ( true ); cardPayment . setTokenUsageIndicator ( true ); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ); Card Field \u00b6 Card Field is a feature where card information (card number, expiration date and CVV) is entered into a single, dynamically changing field instead of multiple separate ones. Here's example code for a card payment using this feature: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class KotlinCardFormActivity : AppCompatActivity (), Observer < PaymentResponse > { private val mContext = this private val mPaymentObjectProvider = PaymentObjectProvider () private lateinit var cardFieldFragment : CardFieldFragment override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_card_form ) cardFieldFragment = CardFieldFragment . Builder (). build () supportFragmentManager . beginTransaction () . add ( R . id . card_field_container , cardFieldFragment ) . commit () cardFieldFragment . getEventObserver () . subscribe { state -> Log . i ( \"event\" , state . toString ()) } } fun onSubmitButtonClicked ( view : View ) { if ( cardFieldFragment . getCardBundle () != null ) { Client ( this , URL_EE_TEST , null , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( cardFieldFragment . getCardBundle ())) findViewById < View >( R . id . progress ). visibility = View . VISIBLE } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show () } } fun getCardFormPayment ( cardBundle : CardBundle ): CardFormPayment { val merchantID = \"merchant_id\" val secretKey = \"secret_key\" val requestID = UUID . randomUUID (). toString () val transactionType = TransactionType . PURCHASE val amount = BigDecimal ( 5 ) val currency = \"EUR\" val signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . value , amount , currency , secretKey ) val cardFormPayment = CardFormPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build () val accountHolder = AccountHolder ( \"John\" , \"Doe\" ) cardFormPayment . accountHolder = accountHolder return cardFormPayment } override fun onObserve ( paymentResponse : PaymentResponse ) { runOnUiThread { Toast . makeText ( mContext , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show () findViewById < View >( R . id . progress ). visibility = View . GONE } } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class CardFormActivity extends AppCompatActivity implements Observer < PaymentResponse > { private Context mContext = this ; private PaymentObjectProvider mPaymentObjectProvider = new PaymentObjectProvider (); CardFieldFragment cardFieldFragment ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_card_form ); cardFieldFragment = new CardFieldFragment . Builder (). build (); getSupportFragmentManager () . beginTransaction () . add ( R . id . card_field_container , cardFieldFragment ) . commit (); cardFieldFragment . getEventObserver () . subscribe ( state -> { Log . i ( \"event\" , state . toString ()); } ); } public void onSubmitButtonClicked ( View view ) { if ( cardFieldFragment . getCardBundle () != null ) { new Client ( this , URL_EE_TEST , null , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( cardFieldFragment . getCardBundle ())); findViewById ( R . id . progress ). setVisibility ( View . VISIBLE ); } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show (); } } public CardFormPayment getCardFormPayment ( CardBundle cardBundle ) { String merchantID = \"merchant_id\" ; String secretKey = \"secret_key\" ; String requestID = UUID . randomUUID (). toString (); TransactionType transactionType = TransactionType . PURCHASE ; BigDecimal amount = new BigDecimal ( 5 ); String currency = \"EUR\" ; String signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . getValue (), amount , currency , secretKey ); CardFormPayment cardFormPayment = new CardFormPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build (); AccountHolder accountHolder = new AccountHolder ( \"John\" , \"Doe\" ); cardFormPayment . setAccountHolder ( accountHolder ); return cardFormPayment ; } @Override public void onObserve ( PaymentResponse paymentResponse ) { runOnUiThread (() -> { Toast . makeText ( mContext , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show (); findViewById ( R . id . progress ). setVisibility ( View . GONE ); } ); } } Additional Options for Card Field \u00b6 You can set additional options for Card Field through CardFieldFragment.Builder : SetSupportedCardBrands - sets allowed card brands (providers) setExpirationDate - used in token payments setRequestFocus - sets screen focus (after the card form loads) setHideCardIcon - hides provider icons (VISA, Maestro, etc.) setToken - used in token payments setMaskedCardNumber - used in token payments setCardBrand - sets the card brand/provider setTextSize - changes text size setLocale - changes the payment locale setNativeLocale - changes the payment locale (UI only) Token Payment with Card Field \u00b6 The payment object is identical to a normal card field payment (like the example above), but you need to include the card token. Kotlin 1 2 3 4 5 6 7 ... val cardToken = CardToken () cardToken . tokenId = \"12345678901111\" cardPayment . cardToken = cardToken cardToken . tokenUsageIndicator = true cardToken . requireSecurityCode = true ... Java 1 2 3 4 5 6 7 8 ... CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"12345678901111\" ); cardPayment . setCardToken ( cardToken ); cardPayment . setRequireSecurityCode ( true ); cardPayment . setTokenUsageIndicator ( true ); ... Customizing Visuals \u00b6 To change colors within the SDK, override the default color values in the .xml file. Color Resources \u00b6 Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Fonts \u00b6 To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 Changing Text Size \u00b6 To change the text size for cardField fragments use the dimension attribute wd_ecom_cardfield_text_size . To change text size in any other modules use the dimension attribute wd_ecom_text_size . Customizing Simple Card Payments \u00b6 Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_main_alpha80 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_toolbar_text 6 - wd_ecom_color_error 7 - wd_ecom_color_main_background Icons 8 - wd_ecom_arrow_back 9 - wd_ecom_cardholder_name 10 - wd_ecom_camera_blue 11 - wd_ecom_date 12 - wd_ecom_lock Customizing Animated Card Payments \u00b6 Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_toolbar_text 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_main_alpha80 6 - wd_ecom_color_main_alpha40 7 - wd_ecom_color_error 8 - wd_ecom_color_main_background Icons 9 - wd_ecom_arrow_back 10 - wd_ecom_chip Customizing cardField Fragments \u00b6 Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_error","title":"Card Payments"},{"location":"card-payments/#card-payments","text":"","title":"Card Payments"},{"location":"card-payments/#supported-transaction-types","text":"This payment method supports the following transaction types : WDECTransactionTypeAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. WDECTransactionTypeAuthorizationOnly - verifies the validity of account holder's card, but does not leave an authorized amount. WDECTransactionTypePurchase - charges the account holder's card and immediately transfers the reserved amount. WDECTransactionTypeReferencedAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. References a previous WDECTransactionTypeAuthorization transaction. WDECTransactionTypeReferencedPurchase - charges the account holder's card and immediately transfers the reserved amount. References a previous WDECTransactionTypePurchase transaction. WDECTransactionTypeTokenize - provides a unique token which represents the tokenized card data. This token then can be used in future transactions.","title":"Supported Transaction Types"},{"location":"card-payments/#basic-setup","text":"","title":"Basic Setup"},{"location":"card-payments/#cocoapods","text":"Add to your app's Podfile subspecs: 1 2 3 pod 'paymentSDK/Card' , '~> 3.0.0' # just by adding card scanner subspec consumers get option to scan card pod 'paymentSDK/CardScanner' , '~> 3.0.0'","title":"Cocoapods"},{"location":"card-payments/#camera-permission","text":"To make sure Card Scanner has permission before using camera to scan card, follow the steps in Apple documentation . You need to include NSCameraUsageDescription in your app's Info.plist file.","title":"Camera Permission"},{"location":"card-payments/#basic-card-payment","text":"This is a code example for a basic card payment: Swift 1 Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; Note: You can set optional parameters after the payment object is created. Check the API documentation: WDECCardPayment and for more details.","title":"Basic Card Payment"},{"location":"card-payments/#token-payment","text":"This is a code example for a card payment which uses a card token (obtained from a previous transaction): Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val cardPayment = CardPayment ( signature , requestID , merchantID , transactionType , amount , currency ) // for enabling animated card layout cardPayment . animatedCardPayment = true val cardToken = CardToken () cardToken . tokenId = \"12345678901111\" cardPayment . cardToken = cardToken cardToken . tokenUsageIndicator = true cardToken . requireSecurityCode = true Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cardPayment = new CardPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . build (); // for enabling animated card layout cardPayment . setAnimatedCardPayment ( true ); CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"12345678901111\" ); cardPayment . setCardToken ( cardToken ); cardPayment . setRequireSecurityCode ( true ); cardPayment . setTokenUsageIndicator ( true ); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment );","title":"Token payment"},{"location":"card-payments/#card-field","text":"Card Field is a feature where card information (card number, expiration date and CVV) is entered into a single, dynamically changing field instead of multiple separate ones. Here's example code for a card payment using this feature: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class KotlinCardFormActivity : AppCompatActivity (), Observer < PaymentResponse > { private val mContext = this private val mPaymentObjectProvider = PaymentObjectProvider () private lateinit var cardFieldFragment : CardFieldFragment override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_card_form ) cardFieldFragment = CardFieldFragment . Builder (). build () supportFragmentManager . beginTransaction () . add ( R . id . card_field_container , cardFieldFragment ) . commit () cardFieldFragment . getEventObserver () . subscribe { state -> Log . i ( \"event\" , state . toString ()) } } fun onSubmitButtonClicked ( view : View ) { if ( cardFieldFragment . getCardBundle () != null ) { Client ( this , URL_EE_TEST , null , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( cardFieldFragment . getCardBundle ())) findViewById < View >( R . id . progress ). visibility = View . VISIBLE } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show () } } fun getCardFormPayment ( cardBundle : CardBundle ): CardFormPayment { val merchantID = \"merchant_id\" val secretKey = \"secret_key\" val requestID = UUID . randomUUID (). toString () val transactionType = TransactionType . PURCHASE val amount = BigDecimal ( 5 ) val currency = \"EUR\" val signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . value , amount , currency , secretKey ) val cardFormPayment = CardFormPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build () val accountHolder = AccountHolder ( \"John\" , \"Doe\" ) cardFormPayment . accountHolder = accountHolder return cardFormPayment } override fun onObserve ( paymentResponse : PaymentResponse ) { runOnUiThread { Toast . makeText ( mContext , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show () findViewById < View >( R . id . progress ). visibility = View . GONE } } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class CardFormActivity extends AppCompatActivity implements Observer < PaymentResponse > { private Context mContext = this ; private PaymentObjectProvider mPaymentObjectProvider = new PaymentObjectProvider (); CardFieldFragment cardFieldFragment ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_card_form ); cardFieldFragment = new CardFieldFragment . Builder (). build (); getSupportFragmentManager () . beginTransaction () . add ( R . id . card_field_container , cardFieldFragment ) . commit (); cardFieldFragment . getEventObserver () . subscribe ( state -> { Log . i ( \"event\" , state . toString ()); } ); } public void onSubmitButtonClicked ( View view ) { if ( cardFieldFragment . getCardBundle () != null ) { new Client ( this , URL_EE_TEST , null , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( cardFieldFragment . getCardBundle ())); findViewById ( R . id . progress ). setVisibility ( View . VISIBLE ); } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show (); } } public CardFormPayment getCardFormPayment ( CardBundle cardBundle ) { String merchantID = \"merchant_id\" ; String secretKey = \"secret_key\" ; String requestID = UUID . randomUUID (). toString (); TransactionType transactionType = TransactionType . PURCHASE ; BigDecimal amount = new BigDecimal ( 5 ); String currency = \"EUR\" ; String signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . getValue (), amount , currency , secretKey ); CardFormPayment cardFormPayment = new CardFormPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build (); AccountHolder accountHolder = new AccountHolder ( \"John\" , \"Doe\" ); cardFormPayment . setAccountHolder ( accountHolder ); return cardFormPayment ; } @Override public void onObserve ( PaymentResponse paymentResponse ) { runOnUiThread (() -> { Toast . makeText ( mContext , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show (); findViewById ( R . id . progress ). setVisibility ( View . GONE ); } ); } }","title":"Card Field"},{"location":"card-payments/#additional-options-for-card-field","text":"You can set additional options for Card Field through CardFieldFragment.Builder : SetSupportedCardBrands - sets allowed card brands (providers) setExpirationDate - used in token payments setRequestFocus - sets screen focus (after the card form loads) setHideCardIcon - hides provider icons (VISA, Maestro, etc.) setToken - used in token payments setMaskedCardNumber - used in token payments setCardBrand - sets the card brand/provider setTextSize - changes text size setLocale - changes the payment locale setNativeLocale - changes the payment locale (UI only)","title":"Additional Options for Card Field"},{"location":"card-payments/#token-payment-with-card-field","text":"The payment object is identical to a normal card field payment (like the example above), but you need to include the card token. Kotlin 1 2 3 4 5 6 7 ... val cardToken = CardToken () cardToken . tokenId = \"12345678901111\" cardPayment . cardToken = cardToken cardToken . tokenUsageIndicator = true cardToken . requireSecurityCode = true ... Java 1 2 3 4 5 6 7 8 ... CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"12345678901111\" ); cardPayment . setCardToken ( cardToken ); cardPayment . setRequireSecurityCode ( true ); cardPayment . setTokenUsageIndicator ( true ); ...","title":"Token Payment with Card Field"},{"location":"card-payments/#customizing-visuals","text":"To change colors within the SDK, override the default color values in the .xml file.","title":"Customizing Visuals"},{"location":"card-payments/#color-resources","text":"Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Color Resources"},{"location":"card-payments/#changing-fonts","text":"To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1","title":"Changing Fonts"},{"location":"card-payments/#changing-text-size","text":"To change the text size for cardField fragments use the dimension attribute wd_ecom_cardfield_text_size . To change text size in any other modules use the dimension attribute wd_ecom_text_size .","title":"Changing Text Size"},{"location":"card-payments/#customizing-simple-card-payments","text":"Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_main_alpha80 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_toolbar_text 6 - wd_ecom_color_error 7 - wd_ecom_color_main_background Icons 8 - wd_ecom_arrow_back 9 - wd_ecom_cardholder_name 10 - wd_ecom_camera_blue 11 - wd_ecom_date 12 - wd_ecom_lock","title":"Customizing Simple Card Payments"},{"location":"card-payments/#customizing-animated-card-payments","text":"Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_toolbar_text 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_main_alpha80 6 - wd_ecom_color_main_alpha40 7 - wd_ecom_color_error 8 - wd_ecom_color_main_background Icons 9 - wd_ecom_arrow_back 10 - wd_ecom_chip","title":"Customizing Animated Card Payments"},{"location":"card-payments/#customizing-cardfield-fragments","text":"Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_error","title":"Customizing cardField Fragments"},{"location":"license/","text":"paymentSDK - MIT License \u00b6 Copyright 2019, Wirecard AG Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 3 rd party licenses \u00b6 AFNetworking - MIT License CocoaLumberjack - BSD 3-Clause License GoogleMobileVision - Custom IBAN - BSD 2-Clause License libextobjc - MIT License Lockbox - MIT License Mantle - MIT License MBProgressHUD - MIT License TPKeyboardAvoiding - zlib License ZappMerchantLib - Apache License 2.0","title":"License"},{"location":"license/#paymentsdk-mit-license","text":"Copyright 2019, Wirecard AG Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"paymentSDK - MIT License"},{"location":"license/#3rd-party-licenses","text":"AFNetworking - MIT License CocoaLumberjack - BSD 3-Clause License GoogleMobileVision - Custom IBAN - BSD 2-Clause License libextobjc - MIT License Lockbox - MIT License Mantle - MIT License MBProgressHUD - MIT License TPKeyboardAvoiding - zlib License ZappMerchantLib - Apache License 2.0","title":"3rd party licenses"},{"location":"localization/","text":"Localization \u00b6 You can set two types of locale - locale and localeUIOnly - in 3 combinations: 1. locale is set - selected locale is sent to the backend and the UI is set to specified language, 2. localeUIOnly is set - locale is not sent to backend, but UI is set to specified language, 3. Both locale and localeUIOnly are set - the locale string is sent to backend and the UI is set according to localeUIOnly . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . locale = \"DE\" cardPayment . localeUIOnly = \"RU\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) This example shows the 3rd option (dual setting): the backend locale is set to DE and the frontend localeUIOnly to RU. This means that although the backend locale backend is DE, the UI language is RU. Override strings \u00b6 All strings are saved in the strings.xml file for all supported languages. In it you can find every possible language key. Important: Do not delete any special characters (e.g. {0}) to avoid errors.","title":"Localization"},{"location":"localization/#localization","text":"You can set two types of locale - locale and localeUIOnly - in 3 combinations: 1. locale is set - selected locale is sent to the backend and the UI is set to specified language, 2. localeUIOnly is set - locale is not sent to backend, but UI is set to specified language, 3. Both locale and localeUIOnly are set - the locale string is sent to backend and the UI is set according to localeUIOnly . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . locale = \"DE\" cardPayment . localeUIOnly = \"RU\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) This example shows the 3rd option (dual setting): the backend locale is set to DE and the frontend localeUIOnly to RU. This means that although the backend locale backend is DE, the UI language is RU.","title":"Localization"},{"location":"localization/#override-strings","text":"All strings are saved in the strings.xml file for all supported languages. In it you can find every possible language key. Important: Do not delete any special characters (e.g. {0}) to avoid errors.","title":"Override strings"},{"location":"paypal/","text":"PayPal \u00b6 Supported Transaction Types \u00b6 This payment method supports the following transaction types: debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. authorization-only - verifies the validity of account holder's card, but does not leave an authorized amount. capture-authorization - captures a previously authorized amount from the account holder's card. Must refer to an existing authorization transaction. Module Dependency \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ext { wirecardEcomLibraryVersion = \"0.0.8\" } android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard-paymentsdk/wirecard-ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:paypal:$wirecardEcomLibraryVersion\" ... } Basic PayPal Payment \u00b6 PayPal requires additional setup of the wd_ecom_paypal_scheme and wd_ecom_paypal_host resources so you can receive responses from PayPal: 1 2 3 4 5 6 <resources> ... <string name= \"wd_ecom_paypal_scheme\" > yourapp </string> <string name= \"wd_ecom_paypal_host\" > result.paypal </string> ... </resources> Then you can go ahead and create the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 val paypalPayment = PayPalPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = null , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( paypalPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 PayPalPayment payPalPayment = new PayPalPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( paymentState . getAmount ()) . setCurrency ( currency ) . setPeriodic ( null ) . setRiskReferenceId ( null ) . build (); Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( paypalPayment ) Recurring PayPal Payment \u00b6 On a basic level, recurring payments have two phases: The initial request, which must include: periodic type set to RECURRING , sequence type set to FIRST . The \"recurring\"/follow-up requests, which must include: periodic type set to RECURRING , sequence type set to SEQUENCE , parentTransactionId and riskReferenceId values from the initial request. So in order to create a recurring payment, you need to: Send a initial request with the appropriate periodic and sequence flags, Save the values of parentTransactionId and riskReferenceId fields generated in this first payment, Reference these values in the follow-up request, then send it with appropriate periodic and sequence flags. Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // first payment val firstPeriodicType = Periodic () firstPeriodicType . periodicType = PeriodicType . RECURRING . value firstPeriodicType . sequenceType = SequenceType . FIRST . value val firstPaypalPayment = PayPalPayment ( signature = signature , requestTimeStamp = timestamp , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = firstPeriodicType , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( firstPaypalPayment ) ... // handle first result private var parentTransactionId : String ? = null private var riskReferenceId : String ? = null override fun onActivityResult ( requestCode : Int , resultCode : Int , data : Intent ?) { super . onActivityResult ( requestCode , resultCode , data ) val paymentSdkResponse = data ?. getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ) if ( paymentSdkResponse is PaymentResponse ) { parentTransactionId = paymentSdkResponse . payment ?. parentTransactionId riskReferenceId = paymentSdkResponse . payment ?. riskReferenceId } } // second payment using parentTransactionId and riskReferenceId val secondPeriodicType = Periodic () secondPeriodicType . periodicType = PeriodicType . RECURRING . value secondPeriodicType . sequenceType = SequenceType . SEQUENCE . value val secondPaypalPayment = PayPalPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = secondPeriodicType , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( secondPaypalPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // first payment Periodic firstPeriodicType = new Periodic (); firstPeriodicType . periodicType = PeriodicType . RECURRING . value ; firstPeriodicType . sequenceType = SequenceType . FIRST . value ; PayPalPayment firstPaypalPayment = PayPalPayment ( signature , requestID , merchantID , transactionType , amount , currency , firstPeriodicType , null ); new Client ( this , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( firstPaypalPayment ); ... // handle first result private String parentTransactionId = null ; private String riskReferenceId = null ; protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ); Serializable paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ); if ( paymentSdkResponse instanceof PaymentResponse ) { parentTransactionId = paymentSdkResponse . payment . getParentTransactionId (); riskReferenceId = paymentSdkResponse . payment . getRiskReferenceId (); } } // second payment using parentTransactionId and riskReferenceId; Periodic secondPeriodicType = new Periodic (); secondPeriodicType . periodicType = PeriodicType . RECURRING . value ; secondPeriodicType . sequenceType = SequenceType . SEQUENCE . value ; PayPalPayment secondPaypalPayment = PayPalPayment ( signature , requestID , merchantID , transactionType , amount , currency , secondPeriodicType , riskReferenceId ); new Client ( this , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( secondPaypalPayment ); Customizing Visuals \u00b6 To change colors within the SDK, override the default color values in the .xml file. Color Resources \u00b6 Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Fonts \u00b6 To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 Changing Text Size \u00b6 To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"PayPal"},{"location":"paypal/#paypal","text":"","title":"PayPal"},{"location":"paypal/#supported-transaction-types","text":"This payment method supports the following transaction types: debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. authorization-only - verifies the validity of account holder's card, but does not leave an authorized amount. capture-authorization - captures a previously authorized amount from the account holder's card. Must refer to an existing authorization transaction.","title":"Supported Transaction Types"},{"location":"paypal/#module-dependency","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ext { wirecardEcomLibraryVersion = \"0.0.8\" } android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard-paymentsdk/wirecard-ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:paypal:$wirecardEcomLibraryVersion\" ... }","title":"Module Dependency"},{"location":"paypal/#basic-paypal-payment","text":"PayPal requires additional setup of the wd_ecom_paypal_scheme and wd_ecom_paypal_host resources so you can receive responses from PayPal: 1 2 3 4 5 6 <resources> ... <string name= \"wd_ecom_paypal_scheme\" > yourapp </string> <string name= \"wd_ecom_paypal_host\" > result.paypal </string> ... </resources> Then you can go ahead and create the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 val paypalPayment = PayPalPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = null , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( paypalPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 PayPalPayment payPalPayment = new PayPalPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( paymentState . getAmount ()) . setCurrency ( currency ) . setPeriodic ( null ) . setRiskReferenceId ( null ) . build (); Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( paypalPayment )","title":"Basic PayPal Payment"},{"location":"paypal/#recurring-paypal-payment","text":"On a basic level, recurring payments have two phases: The initial request, which must include: periodic type set to RECURRING , sequence type set to FIRST . The \"recurring\"/follow-up requests, which must include: periodic type set to RECURRING , sequence type set to SEQUENCE , parentTransactionId and riskReferenceId values from the initial request. So in order to create a recurring payment, you need to: Send a initial request with the appropriate periodic and sequence flags, Save the values of parentTransactionId and riskReferenceId fields generated in this first payment, Reference these values in the follow-up request, then send it with appropriate periodic and sequence flags. Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // first payment val firstPeriodicType = Periodic () firstPeriodicType . periodicType = PeriodicType . RECURRING . value firstPeriodicType . sequenceType = SequenceType . FIRST . value val firstPaypalPayment = PayPalPayment ( signature = signature , requestTimeStamp = timestamp , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = firstPeriodicType , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( firstPaypalPayment ) ... // handle first result private var parentTransactionId : String ? = null private var riskReferenceId : String ? = null override fun onActivityResult ( requestCode : Int , resultCode : Int , data : Intent ?) { super . onActivityResult ( requestCode , resultCode , data ) val paymentSdkResponse = data ?. getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ) if ( paymentSdkResponse is PaymentResponse ) { parentTransactionId = paymentSdkResponse . payment ?. parentTransactionId riskReferenceId = paymentSdkResponse . payment ?. riskReferenceId } } // second payment using parentTransactionId and riskReferenceId val secondPeriodicType = Periodic () secondPeriodicType . periodicType = PeriodicType . RECURRING . value secondPeriodicType . sequenceType = SequenceType . SEQUENCE . value val secondPaypalPayment = PayPalPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = secondPeriodicType , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( secondPaypalPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // first payment Periodic firstPeriodicType = new Periodic (); firstPeriodicType . periodicType = PeriodicType . RECURRING . value ; firstPeriodicType . sequenceType = SequenceType . FIRST . value ; PayPalPayment firstPaypalPayment = PayPalPayment ( signature , requestID , merchantID , transactionType , amount , currency , firstPeriodicType , null ); new Client ( this , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( firstPaypalPayment ); ... // handle first result private String parentTransactionId = null ; private String riskReferenceId = null ; protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ); Serializable paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ); if ( paymentSdkResponse instanceof PaymentResponse ) { parentTransactionId = paymentSdkResponse . payment . getParentTransactionId (); riskReferenceId = paymentSdkResponse . payment . getRiskReferenceId (); } } // second payment using parentTransactionId and riskReferenceId; Periodic secondPeriodicType = new Periodic (); secondPeriodicType . periodicType = PeriodicType . RECURRING . value ; secondPeriodicType . sequenceType = SequenceType . SEQUENCE . value ; PayPalPayment secondPaypalPayment = PayPalPayment ( signature , requestID , merchantID , transactionType , amount , currency , secondPeriodicType , riskReferenceId ); new Client ( this , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( secondPaypalPayment );","title":"Recurring PayPal Payment"},{"location":"paypal/#customizing-visuals","text":"To change colors within the SDK, override the default color values in the .xml file.","title":"Customizing Visuals"},{"location":"paypal/#color-resources","text":"Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Color Resources"},{"location":"paypal/#changing-fonts","text":"To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1","title":"Changing Fonts"},{"location":"paypal/#changing-text-size","text":"To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"Changing Text Size"},{"location":"release-notes/","text":"","title":"Release Notes"},{"location":"sepa/","text":"SEPA \u00b6 Supported Transaction Types \u00b6 debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. pending-debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. The pending status indicates that additional processing/approval is required before the transaction is cleared. Module Implementation \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ext { wirecardEcomLibraryVersion = \"0.0.8\" } android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard-paymentsdk/wirecard-ecom-android\" } } dependencies { ... implementation ( \"com.wirecard.ecom:sepa:$wirecardEcomLibraryVersion\" ) { // exclude module: 'play-services-vision' } ... } To disable the IBAN scanner feature, uncomment the exclude module line. When adding/removing this feature, perform a full clean build. If you intend to use Card Payments module together with the SEPA Direct Debit module (with IBAN scanner), you must enable/disable it in both modules. Simple SEPA Payment \u00b6 This is a code example for a basic SEPA payment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val sepaPayment = SepaPayment ( signature = signature , requestTimeStamp = timestamp , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , creditorId = null , mandateId = null , mandateSignedDate = null , merchantName = \"JOHN DOE\" , dueDate = null , periodic = null , B2B = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( sepaPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 sepaPayment = new SepaPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . setMerchantName ( \"JOHN DOE\" ) . build (); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( sepaPayment ); You can use Builder to create the payment object and set additional properties afterwards. Customizing Visuals \u00b6 To change colors within the SDK, override the default color values in the .xml file. Color Resources \u00b6 Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Fonts \u00b6 To change fonts, add the font path to the payment object: 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Changing Text Size \u00b6 To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField . Customizing SEPA Payments \u00b6 Color Resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_main_alpha80 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_toolbar_text 6 - wd_ecom_color_error 7 - wd_ecom_color_main_background Icons 8 - wd_ecom_arrow_back 9 - wd_ecom_cardholder_name 10 - wd_ecom_iban_3 11 - wd_ecom_camera_blue","title":"SEPA Direct Debit"},{"location":"sepa/#sepa","text":"","title":"SEPA"},{"location":"sepa/#supported-transaction-types","text":"debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. pending-debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. The pending status indicates that additional processing/approval is required before the transaction is cleared.","title":"Supported Transaction Types"},{"location":"sepa/#module-implementation","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ext { wirecardEcomLibraryVersion = \"0.0.8\" } android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard-paymentsdk/wirecard-ecom-android\" } } dependencies { ... implementation ( \"com.wirecard.ecom:sepa:$wirecardEcomLibraryVersion\" ) { // exclude module: 'play-services-vision' } ... } To disable the IBAN scanner feature, uncomment the exclude module line. When adding/removing this feature, perform a full clean build. If you intend to use Card Payments module together with the SEPA Direct Debit module (with IBAN scanner), you must enable/disable it in both modules.","title":"Module Implementation"},{"location":"sepa/#simple-sepa-payment","text":"This is a code example for a basic SEPA payment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val sepaPayment = SepaPayment ( signature = signature , requestTimeStamp = timestamp , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , creditorId = null , mandateId = null , mandateSignedDate = null , merchantName = \"JOHN DOE\" , dueDate = null , periodic = null , B2B = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( sepaPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 sepaPayment = new SepaPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . setMerchantName ( \"JOHN DOE\" ) . build (); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( sepaPayment ); You can use Builder to create the payment object and set additional properties afterwards.","title":"Simple SEPA Payment"},{"location":"sepa/#customizing-visuals","text":"To change colors within the SDK, override the default color values in the .xml file.","title":"Customizing Visuals"},{"location":"sepa/#color-resources","text":"Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Color Resources"},{"location":"sepa/#changing-fonts","text":"To change fonts, add the font path to the payment object: 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment )","title":"Changing Fonts"},{"location":"sepa/#changing-text-size","text":"To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"Changing Text Size"},{"location":"sepa/#customizing-sepa-payments","text":"Color Resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_main_alpha80 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_toolbar_text 6 - wd_ecom_color_error 7 - wd_ecom_color_main_background Icons 8 - wd_ecom_arrow_back 9 - wd_ecom_cardholder_name 10 - wd_ecom_iban_3 11 - wd_ecom_camera_blue","title":"Customizing SEPA Payments"},{"location":"theming/","text":"Theming \u00b6 For changing colors within the SDK simply override color values in xml file. Common Color Resources \u00b6 Changing these colors would afect all modules used within SDK. 1 2 3 4 5 6 7 wd_ecom_color_main - colour tint for icons, header and submit button gradient start colour wd_ecom_color_main_light - header and submit button gradient end colour wd_ecom_color_main_alpha80 - text input layout title colour wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text colour wd_ecom_color_main_background - background colour for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Font \u00b6 Simply add font path to payment object as shown in example: 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) missing JAVA code example here? Changing Text Size \u00b6 Use dimen(??) attribute wd_ecom_text_size for changing text size within all modules xcept card field fragment - use wd_ecom_cardfield_text_size. Theming Simple Card Payment Screenshot \u00b6 screenshot with a legend list here Theming Simple Animated Card Payment Screenshot \u00b6 screenshot with a legend list here Theming Card Field Payment Screenshot \u00b6 screenshot with a legend list here Theming Simple SEPA Payment Screenshot \u00b6 screenshot with a legend list here","title":"Theming"},{"location":"theming/#theming","text":"For changing colors within the SDK simply override color values in xml file.","title":"Theming"},{"location":"theming/#common-color-resources","text":"Changing these colors would afect all modules used within SDK. 1 2 3 4 5 6 7 wd_ecom_color_main - colour tint for icons, header and submit button gradient start colour wd_ecom_color_main_light - header and submit button gradient end colour wd_ecom_color_main_alpha80 - text input layout title colour wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text colour wd_ecom_color_main_background - background colour for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Common Color Resources"},{"location":"theming/#changing-font","text":"Simply add font path to payment object as shown in example: 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) missing JAVA code example here?","title":"Changing Font"},{"location":"theming/#changing-text-size","text":"Use dimen(??) attribute wd_ecom_text_size for changing text size within all modules xcept card field fragment - use wd_ecom_cardfield_text_size.","title":"Changing Text Size"},{"location":"theming/#theming-simple-card-payment-screenshot","text":"screenshot with a legend list here","title":"Theming Simple Card Payment Screenshot"},{"location":"theming/#theming-simple-animated-card-payment-screenshot","text":"screenshot with a legend list here","title":"Theming Simple Animated Card Payment Screenshot"},{"location":"theming/#theming-card-field-payment-screenshot","text":"screenshot with a legend list here","title":"Theming Card Field Payment Screenshot"},{"location":"theming/#theming-simple-sepa-payment-screenshot","text":"screenshot with a legend list here","title":"Theming Simple SEPA Payment Screenshot"},{"location":"zapp/","text":"Zapp \u00b6 With Zapp, there are two payments flow. Whether the customer has a banking application installed on their phone decides which one is used : 1. Banking application is installed - this app is opened after a successful response from Wirecard payment gateway. 2. No banking application - SDK prompts a pop-up informing the user to provide BRN (see explanation below) to a banking application on another device and awaits confirmation. BRN is short for Basket Reference Number, a unique temporary code provided by Zapp (and conveyed to the customer by the merchant) which identifies the order which is being paid. Supported Transaction Types \u00b6 debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. Zapp transaction and delivery types \u00b6 Transaction types: BILLPT - Bill payment PAYMT - Retail item payment INVOICE - Invoice payment DONATIONS - Donation payment Delivery types: COLLST - Store collection. The consumer chose to collect the goods from the store personally. DELTAD - Delivery to address. The Consumer chose to have the goods delivered to the specified address. DIGDEL - Digital delivery. The Consumer chose to receive items electronically. SERVICE - Service provided. For SMB transactions where there is no need for a delivery address F2F - Face-to-face transactions. Primarily for use with an SMB transaction. NONE - No delivery Module Dependency \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ext { wirecardEcomLibraryVersion = \"0.0.8\" } android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard-paymentsdk/wirecard-ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:zapp:$wirecardEcomLibraryVersion\" ... } Simple Zapp Payment \u00b6 Zapp requires additional setup of the wd_ecom_zapp_scheme and wd_ecom_zapp_host resources so you can receive responses from Zapp: 1 2 3 4 5 6 <resources> ... <string name= \"wd_ecom_zapp_host\" > yourapp </string> <string name= \"wd_ecom_zapp_scheme\" > open.pbba </string> ... </resources> Then you can go ahead and create the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val zappPayment = ZappPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , zappTransactionType = \"PAYMT\" , zappDeliveryType = \"SERVICE\" , ) zappPayment . ipAddress = \"127.0.0.1\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout = 60 ). startPayment ( zappPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ZappPayment zappPayment = new ZappPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . setZappTransactionType ( \"PAYMNT\" ) . setZappDeliveryType ( \"SERVICE\" ) . build (); zappPayment . setIpAddress ( \"127.0.0.1\" ); new Client ( context , \"https://api-test.wirecard.com\" , 30 ). startPayment ( zappPayment ); Customizing Visuals \u00b6 To change colors within the SDK, override the default color values in the .xml file. Color Resources \u00b6 Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Fonts \u00b6 To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 Changing Text Size \u00b6 To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"Zapp"},{"location":"zapp/#zapp","text":"With Zapp, there are two payments flow. Whether the customer has a banking application installed on their phone decides which one is used : 1. Banking application is installed - this app is opened after a successful response from Wirecard payment gateway. 2. No banking application - SDK prompts a pop-up informing the user to provide BRN (see explanation below) to a banking application on another device and awaits confirmation. BRN is short for Basket Reference Number, a unique temporary code provided by Zapp (and conveyed to the customer by the merchant) which identifies the order which is being paid.","title":"Zapp"},{"location":"zapp/#supported-transaction-types","text":"debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer.","title":"Supported Transaction Types"},{"location":"zapp/#zapp-transaction-and-delivery-types","text":"Transaction types: BILLPT - Bill payment PAYMT - Retail item payment INVOICE - Invoice payment DONATIONS - Donation payment Delivery types: COLLST - Store collection. The consumer chose to collect the goods from the store personally. DELTAD - Delivery to address. The Consumer chose to have the goods delivered to the specified address. DIGDEL - Digital delivery. The Consumer chose to receive items electronically. SERVICE - Service provided. For SMB transactions where there is no need for a delivery address F2F - Face-to-face transactions. Primarily for use with an SMB transaction. NONE - No delivery","title":"Zapp transaction and delivery types"},{"location":"zapp/#module-dependency","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ext { wirecardEcomLibraryVersion = \"0.0.8\" } android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard-paymentsdk/wirecard-ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:zapp:$wirecardEcomLibraryVersion\" ... }","title":"Module Dependency"},{"location":"zapp/#simple-zapp-payment","text":"Zapp requires additional setup of the wd_ecom_zapp_scheme and wd_ecom_zapp_host resources so you can receive responses from Zapp: 1 2 3 4 5 6 <resources> ... <string name= \"wd_ecom_zapp_host\" > yourapp </string> <string name= \"wd_ecom_zapp_scheme\" > open.pbba </string> ... </resources> Then you can go ahead and create the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val zappPayment = ZappPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , zappTransactionType = \"PAYMT\" , zappDeliveryType = \"SERVICE\" , ) zappPayment . ipAddress = \"127.0.0.1\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout = 60 ). startPayment ( zappPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ZappPayment zappPayment = new ZappPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . setZappTransactionType ( \"PAYMNT\" ) . setZappDeliveryType ( \"SERVICE\" ) . build (); zappPayment . setIpAddress ( \"127.0.0.1\" ); new Client ( context , \"https://api-test.wirecard.com\" , 30 ). startPayment ( zappPayment );","title":"Simple Zapp Payment"},{"location":"zapp/#customizing-visuals","text":"To change colors within the SDK, override the default color values in the .xml file.","title":"Customizing Visuals"},{"location":"zapp/#color-resources","text":"Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Color Resources"},{"location":"zapp/#changing-fonts","text":"To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1","title":"Changing Fonts"},{"location":"zapp/#changing-text-size","text":"To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"Changing Text Size"}]}